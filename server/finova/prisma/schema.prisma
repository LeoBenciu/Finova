generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                             Int                      @id @default(autoincrement())
  createdAt                      DateTime                 @default(now())
  updatedAt                      DateTime                 @updatedAt
  email                          String                   @unique
  role                           Role                     @default(ADMIN)
  createdDocumentRelations       DocumentRelationship[]
  hashPassword                   String
  name                           String
  phoneNumber                    String
  accountingCompanyId            Int
  accountingCompany              AccountingCompany        @relation(fields: [accountingCompanyId], references: [id])
  rpaActionsTriggered            RpaAction[]              @relation("TriggeredByUser")
  legalAgreements                LegalAgreement[]
  userCorrections                UserCorrection[]
  reconciledRecords              ReconciliationRecord[]   @relation("ReconciledByUser")
  outstandingItems               OutstandingItem[]
  transferReconciliationsCreated TransferReconciliation[] @relation("TransferCreatedBy")
  // Todos relations
  createdTodos                   TodoItem[]               @relation("User_createdTodos")
  todoAssignees                  TodoAssignee[]
}

model LegalAgreement {
  id            Int      @id @default(autoincrement())
  userId        Int
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  agreementType String
  accepted      Boolean  @default(false)
  acceptedAt    DateTime @default(now())
  ipAddress     String?
  userAgent     String?
  version       String?

  @@unique([userId, agreementType])
  @@index([userId])
}

model Document {
  id                        Int                        @id @default(autoincrement())
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  name                      String
  type                      String
  path                      String
  s3Key                     String
  contentType               String
  fileSize                  Int?
  documentHash              String?
  parentRelations           DocumentRelationship[]     @relation("ParentDocumentRelations")
  childRelations            DocumentRelationship[]     @relation("ChildDocumentRelations")
  references                Int[]
  accountingClientId        Int
  reconciliationStatus      ReconciliationStatus       @default(UNRECONCILED)
  paymentStatus             PaymentStatus              @default(UNPAID)
  totalPaidAmount           Decimal                    @default(0) @db.Decimal(12, 2)
  lastPaymentDate           DateTime?
  bankTransactions          BankTransaction[]          @relation("BankStatementDocument")
  reconciliationRecords     ReconciliationRecord[]
  reconciliationSuggestions ReconciliationSuggestion[]
  potentialReferencesSource PotentialReference[]       @relation("SourceDocument")
  potentialReferencesTarget PotentialReference[]       @relation("TargetDocument")
  accountingClient          AccountingClients          @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)
  processedData             ProcessedData?
  rpaActions                RpaAction[]
  duplicateChecks           DocumentDuplicateCheck[]   @relation("OriginalDocument")
  duplicateMatches          DocumentDuplicateCheck[]   @relation("DuplicateDocument")
  complianceValidations     ComplianceValidation[]
  userCorrections           UserCorrection[]
  paymentSummary            PaymentSummary?
  outstandingItems          OutstandingItem[]
  todos                     TodoItem[]
  ledgerEntries             GeneralLedgerEntry[]

  @@index([documentHash])
  @@index([accountingClientId])
  @@index([reconciliationStatus])
  @@index([paymentStatus])
}

model ProcessedData {
  id              Int      @id @default(autoincrement())
  documentId      Int      @unique
  document        Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  extractedFields Json
}

model DocumentDuplicateCheck {
  id                  Int             @id @default(autoincrement())
  createdAt           DateTime        @default(now())
  originalDocumentId  Int
  duplicateDocumentId Int
  originalDocument    Document        @relation("OriginalDocument", fields: [originalDocumentId], references: [id], onDelete: Cascade)
  duplicateDocument   Document        @relation("DuplicateDocument", fields: [duplicateDocumentId], references: [id], onDelete: Cascade)
  similarityScore     Float
  matchingFields      Json
  duplicateType       DuplicateType
  status              DuplicateStatus @default(PENDING)

  @@unique([originalDocumentId, duplicateDocumentId])
  @@index([originalDocumentId])
  @@index([duplicateDocumentId])
}

model ComplianceValidation {
  id              Int              @id @default(autoincrement())
  createdAt       DateTime         @default(now())
  documentId      Int
  document        Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)
  overallStatus   ComplianceStatus
  overallScore    Float?
  validationRules Json
  errors          Json?
  warnings        Json?
  validatedAt     DateTime         @default(now())

  @@index([documentId])
  @@index([overallStatus])
}

model UserCorrection {
  id             Int            @id @default(autoincrement())
  createdAt      DateTime       @default(now())
  documentId     Int
  document       Document       @relation(fields: [documentId], references: [id], onDelete: Cascade)
  userId         Int
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  correctionType CorrectionType
  originalValue  Json
  correctedValue Json
  confidence     Float?
  applied        Boolean        @default(false)

  @@index([documentId])
  @@index([userId])
  @@index([correctionType])
  @@index([applied])
}

model RpaAction {
  id                 Int               @id @default(autoincrement())
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  documentId         Int
  document           Document          @relation(fields: [documentId], references: [id])
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)
  actionType         RpaActionType
  status             RpaActionStatus   @default(PENDING)
  result             Json?
  triggeredById      Int?
  triggeredBy        User?             @relation("TriggeredByUser", fields: [triggeredById], references: [id])
}

model ClientCompany {
  id                Int                 @id @default(autoincrement())
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  name              String
  ein               String              @unique
  accountingClients AccountingClients[]
  Article           Article[]
  Management        Management[]
}

model AccountingCompany {
  id                Int                 @id @default(autoincrement())
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  name              String
  ein               String              @unique
  uipathSubfolder   String
  clientInvoiceRk   String
  supplierInvoiceRk String
  clientReceiptRk   String
  supplierReceiptRk String
  users             User[]
  accountingClients AccountingClients[]
}

model AccountingClients {
  id                   Int                   @id @default(autoincrement())
  accountingCompanyId  Int
  clientCompanyId      Int
  accountingCompany    AccountingCompany     @relation(fields: [accountingCompanyId], references: [id])
  clientCompany        ClientCompany         @relation(fields: [clientCompanyId], references: [id])
  createdAt            DateTime              @default(now())
  documents            Document[]
  rpaActions           RpaAction[]
  articles             Article[]
  managements          Management[]
  outstandingItems     OutstandingItem[]
  bankAccounts         BankAccount[]
  bankAccountAnalytics BankAccountAnalytic[]
  // Todos scoped to this accounting client
  todos                TodoItem[]
  // Ledger relations
  ledgerEntries        GeneralLedgerEntry[]
  dailyBalances        AccountBalanceDaily[]
  monthlyBalances      AccountBalanceMonthly[]

  @@unique([accountingCompanyId, clientCompanyId])
}

model Article {
  id                 Int               @id @default(autoincrement())
  code               String
  name               String
  vat                VatRate
  unitOfMeasure      UnitOfMeasure
  type               ArticleType
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)
  clientCompanyId    Int
  clientCompany      ClientCompany     @relation(fields: [clientCompanyId], references: [id], onDelete: Cascade)

  @@unique([code, accountingClientId])
  @@index([accountingClientId])
  @@index([clientCompanyId])
}

model DocumentRelationship {
  id               Int                  @id @default(autoincrement())
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  parentDocumentId Int
  childDocumentId  Int
  parentDocument   Document             @relation("ParentDocumentRelations", fields: [parentDocumentId], references: [id], onDelete: Cascade)
  childDocument    Document             @relation("ChildDocumentRelations", fields: [childDocumentId], references: [id], onDelete: Cascade)
  relationshipType DocumentRelationType
  paymentAmount    Float?
  notes            String?
  createdById      Int?
  createdBy        User?                @relation(fields: [createdById], references: [id])

  @@unique([parentDocumentId, childDocumentId])
  @@index([parentDocumentId])
  @@index([childDocumentId])
  @@index([relationshipType])
}

model PaymentSummary {
  id              Int           @id @default(autoincrement())
  documentId      Int           @unique
  document        Document      @relation(fields: [documentId], references: [id], onDelete: Cascade)
  totalAmount     Float // Total invoice amount
  paidAmount      Float         @default(0) // Total amount paid
  remainingAmount Float // Calculated: totalAmount - paidAmount
  paymentStatus   PaymentStatus @default(UNPAID)
  lastPaymentDate DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([paymentStatus])
  @@index([documentId])
}

model Management {
  id                 Int               @id @default(autoincrement())
  code               String
  name               String
  type               ManagementType
  manager            String?
  isSellingPrice     Boolean
  analitic371        String?
  analitic378        String?
  analitic4428       String?
  analitic607        String?
  analitic707        String?
  vatRate            VatRate
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)
  clientCompanyId    Int
  clientCompany      ClientCompany     @relation(fields: [clientCompanyId], references: [id], onDelete: Cascade)

  @@unique([code, accountingClientId])
  @@index([accountingClientId])
  @@index([clientCompanyId])
}

model BankAccount {
  id                 Int               @id @default(autoincrement())
  iban               String            @unique
  accountName        String
  bankName           String
  currency           String            @default("RON")
  accountType        BankAccountType   @default(CURRENT)
  isActive           Boolean           @default(true)
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)
  accountingClientId Int
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt

  // Relations
  bankTransactions BankTransaction[]
  outstandingItems OutstandingItem[]

  @@index([accountingClientId])
  @@index([iban])
  @@index([isActive])
}

model BankTransaction {
  id                        String                     @id
  bankStatementDocument     Document                   @relation("BankStatementDocument", fields: [bankStatementDocumentId], references: [id], onDelete: Cascade)
  bankStatementDocumentId   Int
  transactionDate           DateTime
  description               String
  amount                    Decimal                    @db.Decimal(12, 2)
  transactionType           TransactionType
  referenceNumber           String?
  balanceAfter              Decimal?                   @db.Decimal(12, 2)
  reconciliationStatus      ReconciliationStatus       @default(UNRECONCILED)
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  chartOfAccount            ChartOfAccounts?           @relation(fields: [chartOfAccountId], references: [id])
  chartOfAccountId          Int?
  bankAccount               BankAccount?               @relation(fields: [bankAccountId], references: [id])
  bankAccountId             Int?
  isStandalone              Boolean                    @default(false)
  accountingNotes           String?
  reconciliationRecords     ReconciliationRecord[]
  reconciliationSuggestions ReconciliationSuggestion[]
  outstandingItems          OutstandingItem[]
  splits                    BankTransactionSplit[]
  transferAsSource          TransferReconciliation[]   @relation("SourceTx")
  transferAsDestination     TransferReconciliation[]   @relation("DestTx")
  todos                     TodoItem[]
  ledgerEntries             GeneralLedgerEntry[]

  @@index([bankStatementDocumentId])
  @@index([transactionDate])
  @@index([reconciliationStatus])
  @@index([chartOfAccountId])
  @@index([bankAccountId])
  @@index([isStandalone])
}

model BankTransactionSplit {
  id                Int             @id @default(autoincrement())
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  bankTransaction   BankTransaction @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)
  bankTransactionId String
  amount            Decimal         @db.Decimal(12, 2)
  notes             String?
  chartOfAccount    ChartOfAccounts @relation(fields: [chartOfAccountId], references: [id])
  chartOfAccountId  Int

  @@index([bankTransactionId])
  @@index([chartOfAccountId])
}

model ReconciliationRecord {
  id                Int                        @id @default(autoincrement())
  document          Document                   @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId        Int
  bankTransaction   BankTransaction            @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)
  bankTransactionId String
  matchType         MatchType
  confidenceScore   Decimal?                   @db.Decimal(3, 2)
  reconciledBy      User?                      @relation("ReconciledByUser", fields: [reconciledById], references: [id])
  reconciledById    Int?
  reconciledAt      DateTime                   @default(now())
  notes             String?
  status            ReconciliationRecordStatus @default(ACTIVE)
  createdAt         DateTime                   @default(now())
  ledgerEntries     GeneralLedgerEntry[]

  @@unique([documentId, bankTransactionId])
  @@index([documentId])
  @@index([bankTransactionId])
  @@index([status])
}

model ReconciliationSuggestion {
  id                Int              @id @default(autoincrement())
  document          Document?        @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId        Int?
  bankTransaction   BankTransaction  @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)
  bankTransactionId String
  chartOfAccount    ChartOfAccounts? @relation(fields: [chartOfAccountId], references: [id])
  chartOfAccountId  Int?
  confidenceScore   Decimal          @db.Decimal(4, 3)
  matchingCriteria  Json
  reasons           String[]
  status            SuggestionStatus @default(PENDING)
  createdAt         DateTime         @default(now())

  @@unique([documentId, bankTransactionId])
  @@index([status])
}

model PotentialReference {
  id                       Int             @id @default(autoincrement())
  sourceDocument           Document        @relation("SourceDocument", fields: [sourceDocumentId], references: [id], onDelete: Cascade)
  sourceDocumentId         Int
  referencedDocumentNumber String
  targetDocument           Document?       @relation("TargetDocument", fields: [targetDocumentId], references: [id], onDelete: Cascade)
  targetDocumentId         Int?
  confidence               Decimal?        @db.Decimal(3, 2)
  status                   ReferenceStatus @default(PENDING)
  createdAt                DateTime        @default(now())
  resolvedAt               DateTime?

  @@index([status, referencedDocumentNumber])
  @@index([sourceDocumentId])
  @@index([targetDocumentId])
}

model ChartOfAccounts {
  id                        Int                        @id @default(autoincrement())
  accountCode               String                     @unique
  accountName               String
  accountType               AccountType
  parentAccount             ChartOfAccounts?           @relation("AccountHierarchy", fields: [parentAccountId], references: [id])
  parentAccountId           Int?
  childAccounts             ChartOfAccounts[]          @relation("AccountHierarchy")
  isActive                  Boolean                    @default(true)
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  bankTransactions          BankTransaction[]
  reconciliationSuggestions ReconciliationSuggestion[]
  splits                    BankTransactionSplit[]

  @@index([accountCode])
  @@index([accountType])
  @@index([isActive])
}

model OutstandingItem {
  id                   Int                   @id @default(autoincrement())
  accountingClientId   Int
  accountingClient     AccountingClients     @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)
  type                 OutstandingItemType
  status               OutstandingItemStatus @default(OUTSTANDING)
  referenceNumber      String // Check number, deposit slip number, transfer reference
  description          String
  amount               Decimal               @db.Decimal(10, 2)
  issueDate            DateTime // Date check was written, deposit made, transfer initiated
  expectedClearDate    DateTime? // Expected date to clear
  actualClearDate      DateTime? // Actual date cleared
  daysOutstanding      Int                   @default(0) // Calculated field
  payeeBeneficiary     String? // Who the check is made out to, or deposit source
  bankAccountString    String? // Legacy bank account string field
  bankAccount          BankAccount?          @relation(fields: [bankAccountId], references: [id])
  bankAccountId        Int? // Link to BankAccount entity
  notes                String?
  relatedDocumentId    Int? // Link to related document if applicable
  relatedDocument      Document?             @relation(fields: [relatedDocumentId], references: [id])
  relatedTransactionId String? // Link to bank transaction when cleared
  relatedTransaction   BankTransaction?      @relation(fields: [relatedTransactionId], references: [id])
  createdBy            Int?
  createdByUser        User?                 @relation(fields: [createdBy], references: [id])
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt

  @@index([accountingClientId])
  @@index([type])
  @@index([status])
  @@index([issueDate])
  @@index([daysOutstanding])
  @@index([referenceNumber])
}

/// Maps bank accounts to Romanian analytic codes (e.g., 5121.03 / 5124.02)
model BankAccountAnalytic {
  id                 Int               @id @default(autoincrement())
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)
  iban               String
  currency           String
  syntheticCode      String // 5121 (RON) or 5124 (FX)
  analyticSuffix     String // 01, 02, etc.
  fullCode           String // 5121.03
  bankName           String
  accountAlias       String?

  @@unique([accountingClientId, fullCode])
  @@index([accountingClientId, iban])
}

/// Pairs two opposite-sign bank transactions as an internal transfer
model TransferReconciliation {
  id                       Int      @id @default(autoincrement())
  createdAt                DateTime @default(now())
  sourceTransactionId      String
  destinationTransactionId String
  sourceAccountCode        String
  destinationAccountCode   String
  fxRate                   Decimal? @db.Decimal(12, 6)
  notes                    String?
  createdByUserId          Int

  createdBy              User            @relation("TransferCreatedBy", fields: [createdByUserId], references: [id])
  sourceTransaction      BankTransaction @relation("SourceTx", fields: [sourceTransactionId], references: [id])
  destinationTransaction BankTransaction @relation("DestTx", fields: [destinationTransactionId], references: [id])

  @@unique([sourceTransactionId, destinationTransactionId])
}

enum DocumentRelationType {
  PAYMENT
  CORRECTION
  ATTACHMENT
  CONTRACT_INVOICE
  REFUND
}

enum PaymentStatus {
  UNPAID
  PARTIALLY_PAID
  FULLY_PAID
  OVERPAID
}

enum ManagementType {
  CANTITATIV_VALORIC
  GLOBAL_VALORIC
}

enum ArticleType {
  MARFURI
  MATERII_PRIME
  PRODUSE_FINITE
  SEMIFABRICATE
  SERVICII_VANDUTE
  MATERIALE_AUXILIARE
  AMBALAJE
  TAXA_VERDE
  OBIECTE_DE_INVENTAR
  AMENAJARI_PROVIZORII
  MATERIALE_SPRE_PRELUCRARE
  MATERIALE_IN_PASTRARE_SAU_CONSIGNATIE
  DISCOUNT_FINANCIAR_INTRARI
  DISCOUNT_FINANCIAR_IESIRI
  COMBUSTIBILI
  PIESE_DE_SCHIMB
  PRODUSE_REZIDUALE
  ALTE_MATERIALE_CONSUMABILE
  DISCOUNT_COMERCIAL_INTRARI
  DISCOUNT_COMERCIAL_IESIRI
  AMBALAJE_SGR
}

enum UnitOfMeasure {
  BUCATA
  KILOGRAM
  LITRU
  METRU
  GRAM
  CUTIE
  PACHET
  PUNGA
  SET
  METRU_PATRAT
  METRU_CUB
  MILIMETRU
  CENTIMETRU
  TONA
  PERECHE
  SAC
  MILILITRU
  KILOWATT_ORA
  MINUT
  ORA
  ZI_DE_LUCRU
  LUNI_DE_LUCRU
  DOZA
  UNITATE_DE_SERVICE
  O_MIE_DE_BUCATI
  TRIMESTRU
  PROCENT
  KILOMETRU
  LADA
  DRY_TONE
  CENTIMETRU_PATRAT
  MEGAWATI_ORA
  ROLA
  TAMBUR
  SAC_PLASTIC
  PALET_LEMN
  UNITATE
  TONA_NETA
  HECTOMETRU_PATRAT
  FOAIE
}

enum VatRate {
  ZERO
  NINETEEN
  NINE
  FIVE
}

enum Role {
  USER
  ADMIN
}

enum RpaActionType {
  DATA_ENTRY
  VALIDATION
  CORRECTION
  OTHER
}

enum RpaActionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELED
}

enum DuplicateType {
  EXACT_MATCH
  CONTENT_MATCH
  SIMILAR_CONTENT
}

enum DuplicateStatus {
  PENDING
  CONFIRMED
  DISMISSED
}

enum ComplianceStatus {
  COMPLIANT
  NON_COMPLIANT
  WARNING
  PENDING
}

enum CorrectionType {
  DOCUMENT_TYPE
  INVOICE_DIRECTION
  VENDOR_INFORMATION
  BUYER_INFORMATION
  AMOUNTS
  LINE_ITEMS
  DATES
  OTHER
}

enum BankAccountType {
  CURRENT
  SAVINGS
  BUSINESS
  CREDIT
}

enum TransactionType {
  DEBIT
  CREDIT
}

enum ReconciliationStatus {
  UNRECONCILED
  MATCHED
  IGNORED
}

enum MatchType {
  AUTOMATIC
  MANUAL
  SUGGESTED
}

enum ReconciliationRecordStatus {
  ACTIVE
  DISPUTED
  CANCELLED
}

enum SuggestionStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum ReferenceStatus {
  PENDING
  RESOLVED
  INVALID
}

enum AccountType {
  ASSETS
  LIABILITIES
  INCOME
  EXPENSE
  EQUITY
}

enum OutstandingItemType {
  OUTSTANDING_CHECK
  DEPOSIT_IN_TRANSIT
  PENDING_TRANSFER
}

enum OutstandingItemStatus {
  OUTSTANDING
  CLEARED
  STALE
  VOIDED
}

/// ==================== TODOS ====================
enum TodoStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELED
}

enum TodoPriority {
  LOW
  MEDIUM
  HIGH
}

model TodoItem {
  id          Int          @id @default(autoincrement())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  title       String
  description String?
  status      TodoStatus   @default(PENDING)
  priority    TodoPriority @default(MEDIUM)
  dueDate     DateTime?
  tags        String[]
  // Manual ordering for drag-and-drop sorting (lower comes first)
  sortOrder   Int          @default(0)

  // Scope & relations
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)

  createdById Int
  createdBy   User           @relation("User_createdTodos", fields: [createdById], references: [id])
  assignees   TodoAssignee[]

  relatedDocumentId Int?
  relatedDocument   Document? @relation(fields: [relatedDocumentId], references: [id])

  // Optional linkage to bank transaction id string
  relatedTransactionId String?
  relatedTransaction   BankTransaction? @relation(fields: [relatedTransactionId], references: [id])

  @@index([accountingClientId])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@index([sortOrder])
}

model TodoAssignee {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  todoId Int
  userId Int

  todo TodoItem @relation(fields: [todoId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([todoId, userId])
  @@index([userId])
  @@index([todoId])
}

/// ==================== LEDGER & BALANCES ====================

/// Immutable, double-entry ledger. Each domain event creates balanced rows.
model GeneralLedgerEntry {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  /// Scope to accounting client
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)

  /// Accounting date for the posting
  postingDate DateTime

  /// Romanian chart of account code (e.g., 411, 401, 5121.03). Kept as string for speed/flexibility.
  accountCode String

  /// Monetary amounts (RON by default)
  debit    Decimal @db.Decimal(14, 2)
  credit   Decimal @db.Decimal(14, 2)
  currency String  @default("RON")

  /// Source linkage for auditability/idempotency
  sourceType LedgerSourceType
  sourceId   String // e.g., documentId, bankTransactionId, reconciliationRecordId
  postingKey String           @unique // idempotency key per domain event (e.g., recon:123:accept)

  /// Optional foreign keys for convenience
  documentId        Int?
  document          Document?             @relation(fields: [documentId], references: [id])
  bankTransactionId String?
  bankTransaction   BankTransaction?      @relation(fields: [bankTransactionId], references: [id])
  reconciliationId  Int?
  reconciliation    ReconciliationRecord? @relation(fields: [reconciliationId], references: [id])

  @@index([accountingClientId, postingDate])
  @@index([accountingClientId, accountCode])
  @@index([sourceType])
}

/// Fast-read balances table for instant P&L/BS/CF. Choose Daily; can add Monthly later.
model AccountBalanceDaily {
  id                 Int               @id @default(autoincrement())
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)

  date          DateTime // the day this balance represents (end-of-day)
  accountCode   String
  endingBalance Decimal  @db.Decimal(16, 2)
  lastUpdatedAt DateTime @default(now())

  @@unique([accountingClientId, accountCode, date])
  @@index([accountingClientId, date])
  @@index([accountCode])
}

/// Fast-read monthly balances (as of month-end). Reduces aggregation for reports.
model AccountBalanceMonthly {
  id                 Int               @id @default(autoincrement())
  accountingClientId Int
  accountingClient   AccountingClients @relation(fields: [accountingClientId], references: [id], onDelete: Cascade)

  year         Int
  month        Int              // 1-12
  accountCode  String
  endingBalance Decimal         @db.Decimal(16, 2)
  lastUpdatedAt DateTime        @default(now())

  @@unique([accountingClientId, accountCode, year, month])
  @@index([accountingClientId, year, month])
  @@index([accountCode])
}

enum LedgerSourceType {
  INVOICE_IN
  INVOICE_OUT
  RECEIPT
  PAYMENT_ORDER
  RECONCILIATION
  TRANSFER
  ADJUSTMENT
}
